import type { App } from "@slack/bolt";
import type { HistoryEntry } from "../../auto-reply/reply/history.js";
import type { OpenClawConfig, SlackReactionNotificationMode } from "../../config/config.js";
import type { DmPolicy, GroupPolicy } from "../../config/types.js";
import type { RuntimeEnv } from "../../runtime.js";
import type { SlackMessageEvent } from "../types.js";
import { type SessionScope } from "../../config/sessions.js";
import { getChildLogger } from "../../logging.js";
export declare function inferSlackChannelType(channelId?: string | null): SlackMessageEvent["channel_type"] | undefined;
export declare function normalizeSlackChannelType(channelType?: string | null, channelId?: string | null): SlackMessageEvent["channel_type"];
export type SlackMonitorContext = {
    cfg: OpenClawConfig;
    accountId: string;
    botToken: string;
    app: App;
    runtime: RuntimeEnv;
    botUserId: string;
    teamId: string;
    apiAppId: string;
    historyLimit: number;
    channelHistories: Map<string, HistoryEntry[]>;
    sessionScope: SessionScope;
    mainKey: string;
    dmEnabled: boolean;
    dmPolicy: DmPolicy;
    allowFrom: string[];
    groupDmEnabled: boolean;
    groupDmChannels: string[];
    defaultRequireMention: boolean;
    channelsConfig?: Record<string, {
        enabled?: boolean;
        allow?: boolean;
        requireMention?: boolean;
        allowBots?: boolean;
        users?: Array<string | number>;
        skills?: string[];
        systemPrompt?: string;
    }>;
    groupPolicy: GroupPolicy;
    useAccessGroups: boolean;
    reactionMode: SlackReactionNotificationMode;
    reactionAllowlist: Array<string | number>;
    replyToMode: "off" | "first" | "all";
    threadHistoryScope: "thread" | "channel";
    threadInheritParent: boolean;
    slashCommand: Required<import("../../config/config.js").SlackSlashCommandConfig>;
    textLimit: number;
    ackReactionScope: string;
    mediaMaxBytes: number;
    removeAckAfterReply: boolean;
    logger: ReturnType<typeof getChildLogger>;
    markMessageSeen: (channelId: string | undefined, ts?: string) => boolean;
    shouldDropMismatchedSlackEvent: (body: unknown) => boolean;
    resolveSlackSystemEventSessionKey: (params: {
        channelId?: string | null;
        channelType?: string | null;
    }) => string;
    isChannelAllowed: (params: {
        channelId?: string;
        channelName?: string;
        channelType?: SlackMessageEvent["channel_type"];
    }) => boolean;
    resolveChannelName: (channelId: string) => Promise<{
        name?: string;
        type?: SlackMessageEvent["channel_type"];
        topic?: string;
        purpose?: string;
    }>;
    resolveUserName: (userId: string) => Promise<{
        name?: string;
    }>;
    setSlackThreadStatus: (params: {
        channelId: string;
        threadTs?: string;
        status: string;
    }) => Promise<void>;
};
export declare function createSlackMonitorContext(params: {
    cfg: OpenClawConfig;
    accountId: string;
    botToken: string;
    app: App;
    runtime: RuntimeEnv;
    botUserId: string;
    teamId: string;
    apiAppId: string;
    historyLimit: number;
    sessionScope: SessionScope;
    mainKey: string;
    dmEnabled: boolean;
    dmPolicy: DmPolicy;
    allowFrom: Array<string | number> | undefined;
    groupDmEnabled: boolean;
    groupDmChannels: Array<string | number> | undefined;
    defaultRequireMention?: boolean;
    channelsConfig?: SlackMonitorContext["channelsConfig"];
    groupPolicy: SlackMonitorContext["groupPolicy"];
    useAccessGroups: boolean;
    reactionMode: SlackReactionNotificationMode;
    reactionAllowlist: Array<string | number>;
    replyToMode: SlackMonitorContext["replyToMode"];
    threadHistoryScope: SlackMonitorContext["threadHistoryScope"];
    threadInheritParent: SlackMonitorContext["threadInheritParent"];
    slashCommand: SlackMonitorContext["slashCommand"];
    textLimit: number;
    ackReactionScope: string;
    mediaMaxBytes: number;
    removeAckAfterReply: boolean;
}): SlackMonitorContext;
